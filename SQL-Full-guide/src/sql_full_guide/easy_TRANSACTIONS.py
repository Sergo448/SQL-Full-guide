# -*- coding: utf-8 -*-
# Sergey.6362@mail.ru
# SQL-Full-guide/src/sql_full_guide/easy_TRANSACTIONS.py

import sqlite3

# создаем подключение к нашей базе данных
conn = sqlite3.connect('./DATA_SQL/DATA_BOOK_A', timeout=10)

# Создаем курсор - это специальный объект который делает запросы и получает их результаты
cursor = conn.cursor()

# ТУТ БУДЕТ НАШ КОД РАБОТЫ С БАЗОЙ ДАННЫХ

"""
                TRANSACTION
        Транзакция - это несколько последовательных инструкций 
        SQL, которые вместе образуют логическую единицу работы.
        Инструкции, входящие в транзакцию, обычно тесно связаны
        между собой и выполняют взаимные действия.
        ACID test - аббревиатура, обычно используемая для 
        обозначения четырех характеристик транзакций.
        Atomic (Атомарность) - либо успешно выполняются все операции
        транзакции, либо либо не выполняется ни одна из них.
          
        Consistent (Целостность) - транзакция должна переводить БД
        из одного согласованного состояния в другое. Должны быть выполнены
        все правила и ограничения по окончании транзакции.
        
        Isolated (Изолированность) - каждая транзакция должна
        выполняться сама по себе, без взаимодействия с другими
        транзакциями.
        
        Durable (Постоянство) - по завершении транзакции все 
        внесенные изменения должны быть изменены. Данные должны быть
        в согласованном состоянии.
"""

"""
            The TRANSACTION MODEL
        START TRANSACTION - устанавливает св-ва новой транзакции и запускает ее.
        SET TRANSACTION - устанавливает св-ва очередной выполняемой транзакции,
        не влияет на текущую.
        SET CONSTRAINTS - устанавливает режим ограничений в текущей транзакции.
        SAVEPOINT - создает точку сохранения в пределах транзакции.
        RELEASE SAVEPOINT - освобождает точку сохранения и все ресурсы, которые она
        могла захватить.
        COMMIT - завершает успешную транзакции и сохраняет все изменения в БД.
        ROLLBACK - при использования без точки сохранения, прекращает неудачную транзакцию 
        и выполняет откат всех изменений к началу транзакции, по сути возвращает БД к
        ее согласованному состоянию.
"""

# START TRANSACTION and SET TRANSACTION

"""
        Уровень изоляции:
        READ UNCOMMITTED -  
        READ COMMITTED - 
        REPEATABLE READ - 
        SERIALIZABLE - 
        
        Уровень доступа:
        WRITE ONLY
        READ ONLY
        READ WRITE - default
        
        Размер диагностики:
        Пр. Если размер диагностики = 10, то
        может выполняться до 10 условий при
        выполнении инструкции SQL.
"""

# Пример инструкции которая устанавливает изоляцию..., уровень доступа ... и размер диагностики ...
start_1 = f"START TRANSACTION" \
          f"    ISOLATION LEVEL READ UNCOMMITTED," \
          f"    READ ONLY," \
          f"    DIAGNOSTICS SIZE 5;"


# SAVEPOINT and RELEASE SAVEPOINT

start_1_1 = f"SAVEPOINT name_point_" # создает точку, занимает место в памяти
start_1_2 = f"RELEASE SAVEPOINT name_point_" # удаляет точку явно до завершения транзакции, освобождает место


# COMMIT and ROLLBACK
"""
        COMMIT -> (WORK/...) -> (.../AND [NO] CHAIN) ->>
        
        ROLLBACK -> (WORK/...) -> (.../AND [NO] CHAIN) -> (.../TO SAVEPOINT point_name) ->
        
        WORK - это ключевое слово не выполняет никаких действий и 
        включено в стандарт исключительно для совместимости с некоторыми
        реализациями SQL, треб. его наличия
        
        AND [NO] CHAIN - определяет, должна ли новая транзакция автоматически начинаться с
        теми же свойствами, что и только что завершившаяся.
         
        TO SAVEPOINT - параметр применим только в инструкции ROLLBACK
        Указывает, что откат должен быть выполнен до определенной точки
        сохранения, созданной ранее в транзакции, а не к началу транзакции. 
"""

# Изменить объем заказа ... с ... на ... единиц, что повышает его сумму с ... дл ...
# Заказ на товар ... был принят... (персональный номер 108), который работает в ...
# (офис номер 21...)
tr_1_ex = f"UPDATE ORDERS " \
          f"    SET QTY = 10, AMOUNT = 3550.00" \
          f"    WHERE ORDER_NUM = 113051;" \
          f"UPDATE SALESREPS " \
          f"    SET SALES = SALES - 1458.00 + 3550.00" \
          f"    WHERE EMPL_NUM = 108;" \
          f"UPDATE OFFICES " \
          f"    SET SALES = SALES - 1458.00 + 3550.00" \
          f"    WHERE OFFICE = 21;" \
          f"UPDATE PRODUCTS" \
          f"    SET QTY_ON_HAND = QTY_ON_HAND + 4 - 10" \
          f"    WHERE MFR_ID = 'QSA'" \
          f"    AND PRODUCT_ID = 'XK47';" \
          f"COMMIT WORK;" # Последнее подтверждение введеной информации оператором

tr_1_ex_err = f"UPDATE ORDERS " \
          f"    SET QTY = 10, AMOUNT = 3550.00" \
          f"    WHERE ORDER_NUM = 113051;" \
          f"UPDATE SALESREPS " \
          f"    SET SALES = SALES - 1458.00 + 3550.00" \
          f"    WHERE EMPL_NUM = 108;" \
          f"UPDATE OFFICES " \
          f"    SET SALES = SALES - 1458.00 + 3550.00" \
          f"    WHERE OFFICE = 21;" \
          f"UPDATE PRODUCTS" \
          f"    SET QTY_ON_HAND = QTY_ON_HAND + 4 - 10" \
          f"    WHERE MFR_ID = 'QAS'" \
          f"    AND PRODUCT_ID = 'XK47';" \
          f"ROLLBACK WORK;" # ERROR -> 'QAS' mast be 'QSA'
# Откатились на предыдущий коммит в случае ошибки

# Делаем запрос к базе данных, используя обычный SQL-синтаксис
# cursor.execute(quiery_12)
cursor.execute(tr_1_ex)

# !------------------!------------------!------------------!------------------!------------------!
# Если мы не просто читаем, но и вносим изменения в базу данных - необходимо сохранить транзакцию
conn.commit()
# !------------------!------------------!------------------!------------------!------------------!

results = cursor.fetchall()
print('SQL quiery result:')
print('-----------------')
for s in results:
    print(s)
print('-----------------')
# Не забываем закрыть соединение с базой данных
conn.close()
