# -*- coding: utf-8 -*-
# Sergey.6362@mail.ru
# SQL-Full-guide/src/sql_full_guide/easy_TRANSACTIONS.py

import sqlite3

# создаем подключение к нашей базе данных
conn = sqlite3.connect('./DATA_SQL/DATA_BOOK_A', timeout=10)

# Создаем курсор - это специальный объект который делает запросы и получает их результаты
cursor = conn.cursor()

# ТУТ БУДЕТ НАШ КОД РАБОТЫ С БАЗОЙ ДАННЫХ

"""
                TRANSACTION
        Транзакция - это несколько последовательных инструкций 
        SQL, которые вместе образуют логическую единицу работы.
        Инструкции, входящие в транзакцию, обычно тесно связаны
        между собой и выполняют взаимные действия.
        ACID test - аббревиатура, обычно используемая для 
        обозначения четырех характеристик транзакций.
        Atomic (Атомарность) - либо успешно выполняются все операции
        транзакции, либо либо не выполняется ни одна из них.
          
        Consistent (Целостность) - транзакция должна переводить БД
        из одного согласованного состояния в другое. Должны быть выполнены
        все правила и ограничения по окончании транзакции.
        
        Isolated (Изолированность) - каждая транзакция должна
        выполняться сама по себе, без взаимодействия с другими
        транзакциями.
        
        Durable (Постоянство) - по завершении транзакции все 
        внесенные изменения должны быть изменены. Данные должны быть
        в согласованном состоянии.
"""

"""
            The TRANSACTION MODEL
        START TRANSACTION - устанавливает св-ва новой транзакции и запускает ее.
        SET TRANSACTION - устанавливает св-ва очередной выполняемой транзакции,
        не влияет на текущую.
        SET CONSTRAINTS - устанавливает режим ограничений в текущей транзакции.
        SAVEPOINT - создает точку сохранения в пределах транзакции.
        RELEASE SAVEPOINT - освобождает точку сохранения и все ресурсы, которые она
        могла захватить.
        COMMIT - завершает успешную транзакции и сохраняет все изменения в БД.
        ROLLBACK - при использования без точки сохранения, прекращает неудачную транзакцию 
        и выполняет откат всех изменений к началу транзакции, по сути возвращает БД к
        ее согласованному состоянию.
"""

# START TRANSACTION and SET TRANSACTION

"""
        Уровень изоляции:        Пропавшие          Промежуточные   Несогласованные     Строки-призраки
                                 обновления         данные          данные
        READ UNCOMMITTED -      ПРЕДОТВРАЩАЮТСЯ     ПРЕДОТВРАЩАЮТСЯ ПРЕДОТВРАЩАЮТСЯ     ПРЕДОТВРАЩАЮТСЯ
        READ COMMITTED -        ПРЕДОТВРАЩАЮТСЯ     ПРЕДОТВРАЩАЮТСЯ ПРЕДОТВРАЩАЮТСЯ     ВОЗМОЖНО
        REPEATABLE READ -       ПРЕДОТВРАЩАЮТСЯ     ПРЕДОТВРАЩАЮТСЯ ВОЗМОЖНО            ВОЗМОЖНО
        SERIALIZABLE -          ПРЕДОТВРАЩАЮТСЯ     ВОЗМОЖНО        ВОЗМОЖНО            ВОЗМОЖНО
   
        READ UNCOMMITTED - четвёртый по степени изоляции. На выполнение транзакции
        могу влиять и окончательные и промежуточные итоги выполнения других, 
        параллельно идущих, транзакций. Подходит только для некоторых приложений 
        со специальными запросами, где пользователь может позволить, чтобы 
        результат запроса мог содержать "грязные" данные.
          
        READ COMMITTED - третий по степени изоляции. Транзакция не имеет 
        доступа к промежуточным результатам других транзакций. Однако,
        окончательные результаты других, параллельно выполняемых, транзакций могут 
        быть доступны вашей транзакции. Подходит в случае, если не требуется
        повторно извлекать одну и туже строчку в течении одной транзакции и 
        она не накапливает итоги и не выполняет других действий для которых
        необходимы непротиворечивые данные.
         
        REPEATABLE READ - второй по степени изоляции. Транзакция не имеет 
        доступа к промежуточным или окончательным данным других транзакаций, 
        выполняющих обновление данных. Подходит в случае, если программе не
        требуется повторять многострочный запрос в течении одной транзакции.
        
        SERIALIZABLE - наиболее высокий уровень изоляции. По умолчанию!
   
   
        
        Уровень доступа:
        WRITE ONLY
        READ ONLY
        READ WRITE - default
        
        Размер диагностики:
        Пр. Если размер диагностики = 10, то
        может выполняться до 10 условий при
        выполнении инструкции SQL.
"""

# Пример инструкции которая устанавливает изоляцию..., уровень доступа ... и размер диагностики ...
start_1 = f"START TRANSACTION" \
          f"    ISOLATION LEVEL READ UNCOMMITTED," \
          f"    READ ONLY," \
          f"    DIAGNOSTICS SIZE 5;"


# SAVEPOINT and RELEASE SAVEPOINT

start_1_1 = f"SAVEPOINT name_point_" # создает точку, занимает место в памяти
start_1_2 = f"RELEASE SAVEPOINT name_point_" # удаляет точку явно до завершения транзакции, освобождает место


# COMMIT and ROLLBACK
"""
        COMMIT -> (WORK/...) -> (.../AND [NO] CHAIN) ->>
        
        ROLLBACK -> (WORK/...) -> (.../AND [NO] CHAIN) -> (.../TO SAVEPOINT point_name) ->
        
        WORK - это ключевое слово не выполняет никаких действий и 
        включено в стандарт исключительно для совместимости с некоторыми
        реализациями SQL, треб. его наличия
        
        AND [NO] CHAIN - определяет, должна ли новая транзакция автоматически начинаться с
        теми же свойствами, что и только что завершившаяся.
         
        TO SAVEPOINT - параметр применим только в инструкции ROLLBACK
        Указывает, что откат должен быть выполнен до определенной точки
        сохранения, созданной ранее в транзакции, а не к началу транзакции. 
"""

# Изменить объем заказа ... с ... на ... единиц, что повышает его сумму с ... дл ...
# Заказ на товар ... был принят... (персональный номер 108), который работает в ...
# (офис номер 21...)
tr_1_ex = f"UPDATE ORDERS " \
          f"    SET QTY = 10, AMOUNT = 3550.00" \
          f"    WHERE ORDER_NUM = 113051;" \
          f"UPDATE SALESREPS " \
          f"    SET SALES = SALES - 1458.00 + 3550.00" \
          f"    WHERE EMPL_NUM = 108;" \
          f"UPDATE OFFICES " \
          f"    SET SALES = SALES - 1458.00 + 3550.00" \
          f"    WHERE OFFICE = 21;" \
          f"UPDATE PRODUCTS" \
          f"    SET QTY_ON_HAND = QTY_ON_HAND + 4 - 10" \
          f"    WHERE MFR_ID = 'QSA'" \
          f"    AND PRODUCT_ID = 'XK47';" \
          f"COMMIT WORK;" # Последнее подтверждение введеной информации оператором

tr_1_ex_err = f"UPDATE ORDERS " \
          f"    SET QTY = 10, AMOUNT = 3550.00" \
          f"    WHERE ORDER_NUM = 113051;" \
          f"UPDATE SALESREPS " \
          f"    SET SALES = SALES - 1458.00 + 3550.00" \
          f"    WHERE EMPL_NUM = 108;" \
          f"UPDATE OFFICES " \
          f"    SET SALES = SALES - 1458.00 + 3550.00" \
          f"    WHERE OFFICE = 21;" \
          f"UPDATE PRODUCTS" \
          f"    SET QTY_ON_HAND = QTY_ON_HAND + 4 - 10" \
          f"    WHERE MFR_ID = 'QAS'" \
          f"    AND PRODUCT_ID = 'XK47';" \
          f"ROLLBACK WORK;" # ERROR -> 'QAS' mast be 'QSA'
# Откатились на предыдущий коммит в случае ошибки

"""
        Явная блокировка
        
        В стиле IBM (Например Oracle / DB2)
        LOCK TABLE (table_name) IN (SHARE / EXCLUSIVE) MODE ->
        SHARE - немонопольная блокировка таблицы.
        EXCLUSIVE - монопольная блокировка таблицы
        В стиле MySQL 
        LOCK/UNLOCK TABLES (table_name) IN (SHARE / EXCLUSIVE) MODE ->
"""




# Делаем запрос к базе данных, используя обычный SQL-синтаксис
# cursor.execute(quiery_12)
cursor.execute(tr_1_ex)

# !------------------!------------------!------------------!------------------!------------------!
# Если мы не просто читаем, но и вносим изменения в базу данных - необходимо сохранить транзакцию
conn.commit()
# !------------------!------------------!------------------!------------------!------------------!

results = cursor.fetchall()
print('SQL quiery result:')
print('-----------------')
for s in results:
    print(s)
print('-----------------')
# Не забываем закрыть соединение с базой данных
conn.close()
